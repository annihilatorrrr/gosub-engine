use std::ffi::CStr;
use std::ffi::CString;
use std::os::raw::c_char;
use std::ptr;

use gosub_engine::{
    bytes::{CharIterator, Confidence, Encoding},
    html5::parser::{
        document::{Document, DocumentBuilder},
        Html5Parser,
    },
    render_tree::{Node, NodeType, RenderTree, TreeIterator},
};

#[no_mangle]
/// Initialize a render tree and return an owning pointer to it.
/// If the HTML fails to parse, returns a NULL pointer.
///
/// # Safety
/// Takes a read-only pointer owned from the C API representing the HTML source
/// to build a render tree. DO NOT take ownership of this pointer in Rust or the
/// universe might collapse.
///
/// Moves an owning pointer to the render_tree using Box::into_raw() to the C API.
/// This pointer MUST be passed to gosub_render_tree_free() after usage for proper cleanup.
pub unsafe extern "C" fn gosub_render_tree_init(html: *const c_char) -> *mut RenderTree {
    let html_str: &str;
    unsafe {
        html_str = CStr::from_ptr(html).to_str().unwrap();
    }
    let mut chars = CharIterator::new();
    chars.read_from_str(html_str, Some(Encoding::UTF8));
    chars.set_confidence(Confidence::Certain);

    let doc = DocumentBuilder::new_document();
    let parse_result = Html5Parser::parse_document(&mut chars, Document::clone(&doc), None);

    if parse_result.is_ok() {
        let mut render_tree = Box::new(RenderTree::new(&doc));
        render_tree.build();

        Box::into_raw(render_tree)
    } else {
        ptr::null_mut()
    }
}

#[no_mangle]
/// Construct a tree iterator for a render tree and return an owning pointer to it.
///
/// # Safety
/// Moves an owning pointer to the tree iterator using Box::into_raw() to the C API.
/// This pointer MUST be passed to gosub_render_tree_iterator_free() after usage for proper cleanup.
pub unsafe extern "C" fn gosub_render_tree_iterator_init(
    render_tree: *const RenderTree,
) -> *mut TreeIterator {
    let tree_iterator = Box::new(TreeIterator::new(&(*render_tree)));
    Box::into_raw(tree_iterator)
}

#[no_mangle]
/// Takes a tree_iterator and returns a non-owning pointer to the next node
///
/// # Safety
/// Takes a tree_iterator pointer (owned by the C API generated by gosub_render_tree_iterator_init())
/// and modifies it to point to the next tree-order node in the tree. Any heap-allocated data
/// on the current node is free'd before pointing to the next node. Returns a ready-only pointer
/// to the next node.
pub unsafe extern "C" fn gosub_render_tree_next_node(
    tree_iterator: *mut TreeIterator,
) -> *const Node {
    if let Some(current_node) = (*tree_iterator).current() {
        if let NodeType::Text(text) = &mut current_node.borrow_mut().node_type {
            // recover char* pointers and let Rust free them
            let _ = CString::from_raw(text.font as *mut c_char);
            let _ = CString::from_raw(text.value as *mut c_char);
        }
    }

    let next = (*tree_iterator).next();
    if next.is_none() {
        return ptr::null();
    }
    next.unwrap().as_ptr() as *const Node
}

#[no_mangle]
/// Fetch the node data according to the NodeType of the current node.
///
/// # Safety
/// Uses a read-only pointer obtained from gosub_render_tree_next_node()
/// and a mutable pointer owned by the C API to write (copy) the contents
/// of the read-only pointer into the mutable pointer.
pub unsafe extern "C" fn gosub_render_tree_get_node_data(
    node: *const Node,
    node_data: *mut NodeType,
) {
    *node_data = (*node).node_type;
}

#[no_mangle]
/// Free the iterator pointer obtained from gosub_render_tree_iterator_init()
///
/// # Safety
/// This takes ownership of the pointer from the C API and transfers it to Rust so it can
/// be deallocated.
pub unsafe extern "C" fn gosub_render_tree_iterator_free(tree_iterator: *mut TreeIterator) {
    let _ = Box::from_raw(tree_iterator);
}

#[no_mangle]
/// Free the render_tree pointer obtained from gosub_render_tree_init()
///
/// # Safety
/// This takes ownership of the pointer from the C API and transfers it to Rust so it can
/// be deallocated.
///
// INTERNAL NOTE: It seems there's a leak happening with the document handle (if you
// check with valgrind) although I cannot figure out how to resolve this memory leak...
// needs more investigation; I've tried various methods.
pub unsafe extern "C" fn gosub_render_tree_free(render_tree: *mut RenderTree) {
    let _ = Box::from_raw(render_tree);
}
